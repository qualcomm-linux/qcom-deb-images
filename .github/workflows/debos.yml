name: Build debos recipe

on:
  workflow_call:
    inputs:
      overlays:
        description: List of overlays to use
        type: string
        default: qsc-deb-releases
      kernelpackage:
        description: >
          Kernel package to install from APT repositories (e.g.
          linux-image-arm64) or name of a fileserver kernel package directory
          (e.g. fileserver/mainline)
        type: string
        # the package name will be passed to APT which interprets the trailing
        # plus sign in the package name as a request to install the package, so
        # use two plus signs
        default: linux-image-6.16.7-qcom1++
      debos_extra_args:
        description: Extra arguments to pass to debos (e.g. -t dtb:qcom/some.dtb)
        type: string
        default: ''

    outputs:
      artifacts_url:
        description: "URL to retrieve build artifacts"
        value: ${{ jobs.build-debos.outputs.url }}

# implicitely set all other permissions to none
permissions:
  contents: read # actions/checkout

env:
  # image build id; used for SBOM generation
  BUILD_ID: ${{ github.run_id }}-${{ github.run_attempt }}
  KERNEL_PACKAGE: ${{ inputs.kernelpackage }}
  DEBOS_EXTRA_ARGS: ${{ inputs.debos_extra_args }}

jobs:
  build-debos:
    name: Build and upload debos recipes
    outputs:
      url: ${{ steps.upload_artifacts_gcp.outputs.url }}
    runs-on: [self-hosted, qcom-u2404, arm64]
    container:
      image: public.ecr.aws/debian/debian:trixie
      volumes:
        - /efs/qli/metaqcom/gh-runners/quic-yocto/downloads:/fileserver-downloads
      options: --privileged
    steps:
      # make sure we have latest packages first, to get latest fixes and to
      # avoid an automated update while we're building
      - name: Update OS packages
        run: |
          set -ux
          apt update
          apt -y upgrade
          apt -y full-upgrade

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Copy U-Boot for RB1 from fileserver space for downloads
        run: cp -av "/fileserver-downloads/qcom-deb-images/u-boot-rb1-latest/rb1-boot.img" .

      # mtools is needed for the flash recipe
      - name: Install debos and dependencies of the recipes and local tests
        run: apt -y install debian-archive-keyring debos make mmdebstrap mtools python3-pexpect python3-pytest qemu-efi-aarch64 qemu-system-arm

      - name: Setup local APT repo
        run: |
          set -ux -o pipefail

          # needed for apt-ftparchive
          apt -y install --no-install-recommends apt-utils
          mkdir -v local-apt-repo

          # optionally, copy kernel debs from fileserver
          case "$KERNEL_PACKAGE" in
            fileserver/*)
              fileserver_dir="${KERNEL_PACKAGE#fileserver}"
              mkdir -v local-apt-repo/kernel
              # get kernel from the fileserver space for downloads
              cp -av "/fileserver-downloads/qcom-deb-images/${fileserver_dir}/"*.deb \
                  local-apt-repo/kernel
            ;;
          esac

          (
              cd local-apt-repo
              apt-ftparchive packages . >Packages
              apt-ftparchive release . >Release
          )

      - name: Build rootfs with debos
        run: |
          set -ux
          kernel_package="$KERNEL_PACKAGE"
          # if kernel package is from fileserver, determine actual package name
          case "$kernel_package" in
            fileserver/*)
              kernel_package="$(find local-apt-repo/kernel -type f -name 'linux-image-*' -not -name '*dbg*'|xargs -n1 basename|cut -f1 -d_)"
            ;;
          esac

          debos \
              -t overlays:'${{ inputs.overlays }}' \
              -t xfcedesktop:true \
              -t aptlocalrepo:${PWD}/local-apt-repo \
              -t kernelpackage:"$kernel_package" \
              -t "buildid:${BUILD_ID}" \
              ${DEBOS_EXTRA_ARGS} \
              --print-recipe \
              debos-recipes/qualcomm-linux-debian-rootfs.yaml

      - name: Build UFS and SD card images with debos
        run: |
          set -ux
          # debos tries KVM and UML as backends, and falls back to
          # building directly on the host, but that requires loop
          # devices; use qemu backend explicitly even if it's slower;
          # qemu backend also requires to set scratchsize, otherwise the
          # whole build is done from memory and the out of memory killer
          # gets triggered
          debos -b qemu --scratchsize 6GiB -t imagetype:ufs \
              ${DEBOS_EXTRA_ARGS} \
              --print-recipe \
              debos-recipes/qualcomm-linux-debian-image.yaml
          debos -b qemu --scratchsize 5GiB -t imagetype:sdcard \
              ${DEBOS_EXTRA_ARGS} \
              --print-recipe \
              debos-recipes/qualcomm-linux-debian-image.yaml

      - name: Build flashable files with debos
        run: |
          set -ux
          debos \
              -t u_boot_rb1:rb1-boot.img \
              -t "buildid:${BUILD_ID}" \
              ${DEBOS_EXTRA_ARGS} \
              --print-recipe \
              debos-recipes/qualcomm-linux-debian-flash.yaml

      - name: Stage debos artifacts for publishing
        run: |
          set -ux
          # create a directory for the current run
          dir="debos-artifacts"
          mkdir -v "${dir}"
          # compress output files before staging them
          gzip --keep rootfs.tar rootfs.tar.gz
          # copy output files
          cp -av rootfs.tar.gz "${dir}"
          cp -av dtbs.tar.gz "${dir}"
          cp -av disk-ufs.img.gz "${dir}"
          cp -av disk-sdcard.img.gz "${dir}"
          # create tarballs with support for all UFS and all eMMC boards
          tar -cvzf "${dir}"/flash-ufs.tar.gz \
              disk-ufs.img1 \
              disk-ufs.img2 \
              flash_*_ufs
          tar -cvzf "${dir}"/flash-emmc.tar.gz \
              disk-sdcard.img1 \
              disk-sdcard.img2 \
              flash_*_emmc

      # upload to a cloud storage space accessible by LAVA and developers
      - name: Upload private artifacts (GCP)
        uses: qualcomm-linux/upload-private-artifact-action@v1
        id: upload_artifacts_gcp
        with:
          path: debos-artifacts

      # upload to a cloud storage space accessible by Axiom
      - name: Upload private artifacts (S3)
        uses: qualcomm-linux/upload-private-artifact-action@aws-v3
        with:
          s3_bucket: qcom-prd-gh-artifacts
          # should be the default in that action, or ought to reuse BUILD_ID
          destination: ${{ github.repository_owner }}/${{ github.event.repository.name }}/${{ github.run_id }}-${{ github.run_attempt }}/
          path: debos-artifacts

      - name: Unpack rootfs to generate SBOM
        run: mkdir -v rootfs && tar -C rootfs -xf rootfs.tar

      # Syft is not packaged in Debian; it's available as a binary tarball or
      # as container image from upstream; it's available on arm64 and x86
      - name: Install Syft
        run: |
          set -ux
          apt -y install curl
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh

      - name: Generate SBOMs with Syft
        run: |
          set -ux
          bin/syft --version
          SYFT_FORMAT_PRETTY=true bin/syft \
              -o cyclonedx-json=rootfs-sbom.cyclonedx.json \
              -o spdx-json=rootfs-sbom.spdx.json \
              -o syft-json=rootfs-sbom.syft.json \
              -o syft-text=rootfs-sbom.syft.txt \
              -o syft-table \
              --parallelism `nproc` \
              --select-catalogers debian \
              --source-name qualcomm-linux-debian-rootfs \
              --source-version "${BUILD_ID}" \
              -v \
              scan rootfs

      - name: Generate license summary from Syft report
        run: |
          set -ux
          scripts/syft-license-summary.py \
              --rootfs rootfs rootfs-sbom.syft.json |
                  tee rootfs-sbom.syft-license-summary.csv.txt

      - name: Stage SBOMs for publishing
        run: |
          set -ux
          gzip rootfs-sbom.*
          dir="sboms"
          mkdir -v sboms
          cp -av rootfs-sbom.*.gz sboms

      - name: Upload SBOMs as private artifacts
        uses: qualcomm-linux/upload-private-artifact-action@v1
        id: upload_sbom_artifacts
        with:
          path: sboms
      - name: "Print output"
        env:
          build_url: ${{ steps.upload_artifacts_gcp.outputs.url }}
        run: |
          echo "Downloads URL: ${build_url}"
          echo "url=\"${build_url}\"" >> $GITHUB_OUTPUT
          echo "${build_url}" > build_url
          echo "## Download URL" >> $GITHUB_STEP_SUMMARY
          echo "[${build_url}](${build_url})" >> $GITHUB_STEP_SUMMARY
      - name: Upload build URL
        uses: actions/upload-artifact@v4
        with:
          name: build_url
          path: build_url
      - name: Invoke test runner
        run: |
           # This is currently a clone of Makefile's "test" target to avoid any
           # unexpected interactions with triggering depending build targets.
           # The plan is to move this entire workflow to use make targets
           # instead but all at once. See #74 and #159.

           # rootfs/ is a build artifact, so should not be scanned for tests
           py.test-3 --ignore=rootfs
