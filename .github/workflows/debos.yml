name: Build debos recipe

on:
  # run on pull requests to the main branch
  pull_request:
    branches: [main]
  # run on pushes to the main branch
  push:
    branches: [main]
  # run daily at 8:30am
  schedule:
    - cron: '30 8 * * *'
  # allow manual runs
  workflow_dispatch:

# only need permission to read repository; implicitely set all other
# permissions to none
permissions:
  contents: read

defaults:
  # run all commands from the debos-recipes directory
  run:
    working-directory: debos-recipes

env:
  FILESERVER_URL: https://quic-yocto-fileserver-1029608027416.us-central1.run.app

# cancel in progress builds for this workflow triggered by the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-debos:
    runs-on: [self-hosted, arm64, debbuilder]
    container:
      image: debian:trixie
      volumes:
        - /srv/gh-runners/quic-yocto/builds:/fileserver-builds
      options: --privileged
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download links to Linux deb and U-Boot for RB1
        uses: actions/github-script@v6
        with:
          script: |
            // helper to search for the latest artifact with this name in this
            // repository (not particularly for this workflow run; artifacts
            // we're looking for will only be built from a scheduled (cron)
            // run, and not from pull requests)
            async function lastArtifactByName(name) {
                try {
                    const response =
                        await github.rest.actions.listArtifactsForRepo({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            name: name,
                            page: 1,
                            per_page: 1
                    });
                    if (response.data.artifacts &&
                        response.data.artifacts.length > 0) {
                        return response.data.artifacts[0];
                    } else {
                        console.log(`Artifact with name ${name} not found`);
                    }
                } catch (error) {
                    console.error(`Error listing artifact name ${name}:`,
                        error);
                    throw error;
                }
            }

            // helper to download an artifact by id and save it into filePath
            async function downloadArtifact(artifactId, filePath) {
                try {
                    const response =
                        await github.rest.actions.downloadArtifact({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            artifact_id: artifactId,
                            archive_format: 'zip'
                    });
                    fs.writeFileSync(filePath, Buffer.from(response.data));
                    console.log(`Artifact saved to ${filePath}`);
                } catch (error) {
                    console.error(`Error downloading artifact ${artifactId}:`,
                        error);
                    throw error;
                }
            }

            try {
                let linux_deb_artifact =
                    await lastArtifactByName("linux-deb-links");
                let u_boot_rb1_artifact =
                    await lastArtifactByName("u-boot-rb1-links");

                if (!linux_deb_artifact || !u_boot_rb1_artifact) {
                    console.error('One or both artifacts are missing');
                    process.exit(1);
                }

                await downloadArtifact(linux_deb_artifact_id,
                          'linux-deb-links.zip');
                await downloadArtifact(u_boot_rb1_artifact_id,
                          'u-boot-rb1-links.zip');
            } catch (error) {
                console.error('Error retrieving artifacts: ', error);
                process.exit(1);
            }

      - name: Download Linux deb and U-Boot for RB1 from fileserver
        run: |
            set -ux
            apt update
            apt -y install unzip file
            pwd
            ls
            ls ..
            file ../linux-deb-links.zip
            cat ../linux-deb-links.zip
            unzip -l ../linux-deb-links.zip
            unzip -l ../u-boot-rb1-links.zip
            mkdir linux-deb-links
            mkdir u-boot-rb1-links
            unzip ../linux-deb-links.zip -d linux-deb-links
            unzip ../u-boot-rb1-links.zip -d u-boot-rb1-links
            head u-boot-rb1-links/*
            ls `cat u-boot-rb1-links/*.dir`

      # make sure we have latest packages first, to get latest fixes and to
      # avoid an automated update while we're building
      - name: Update OS packages
        run: |
          set -x
          apt update
          apt -y upgrade
          apt -y full-upgrade
          # debos is needed to build recipes, mtools is needed for the flash
          # recipe
          apt -y install debos mtools

      - name: Build debos recipe
        run: |
          set -x
          # start by building the root filesystem
          debos qualcomm-linux-debian-rootfs.yaml
          # debos tries KVM and UML as backends, and falls back to
          # building directly on the host, but that requires loop
          # devices; use qemu backend explicitly even if it's slower
          # qemu backend also requires to set scratchsize, otherwise the
          # whole build is done from memory and the out of memory killer
          # gets triggered
          debos -b qemu --scratchsize 4GiB -t imagetype:ufs \
              qualcomm-linux-debian-image.yaml
          debos -b qemu --scratchsize 4GiB -t imagetype:sdcard \
              qualcomm-linux-debian-image.yaml
          # build flashable files
          debos qualcomm-linux-debian-flash.yaml

      - name: Upload artifacts to fileserver
        run: |
          set -x
          # curl will be used to talk to fileserver; should be installed by
          # default
          apt -y install curl
          # github runs are only unique per repository and may also be re-run;
          # create an unique id with repository, run id, and run attempt
          id="${GITHUB_REPOSITORY}-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          # create a directory for the current run
          dir="/fileserver-builds/${id}"
          mkdir -vp "${dir}"
          # copy output files
          cp -av rootfs.tar.gz "${dir}"
          cp -av dtbs.tar.gz "${dir}"
          cp -av disk-ufs.img.gz "${dir}"
          cp -av disk-sdcard.img.gz "${dir}"
          tar -cvf "${dir}"/flash.tar.gz disk-ufs.img1 disk-ufs.img2 flash_*
          # instruct fileserver to publish this directory
          url="${FILESERVER_URL}/${id}/"
          curl -X POST -H 'Accept: text/event-stream' "${url}"

