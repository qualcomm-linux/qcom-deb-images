{{- $build_qcs615 := or .build_qcs615 "true" }}
{{- $build_qcm6490 := or .build_qcm6490 "true" }}
{{- $build_qcs8300 := or .build_qcs8300 "true" }}
{{- $build_qcs9100 := or .build_qcs9100 "true" }}
{{- $build_rb1 := "false" -}}
{{- if .u_boot_rb1 -}}
{{- $build_rb1 = "true" }}
{{- end -}}

{{- $target_boards := or .target_boards "all" }}

architecture: arm64

actions:
  - action: download
    description: Download qcom-ptool
    url: https://github.com/qualcomm-linux/qcom-ptool/archive/abf334c24cb24140a8b5c4cc99b633a119244639.tar.gz
    name: qcom-ptool
    filename: qcom-ptool.tar.gz
    unpack: true

{{- $boards := list }}
{{- if eq $build_qcs615 "true" }}
{{- $boards = append $boards (dict
    "name" "qcs615-adp-air-sa6155p"
    "silicon_family" "qcs615"
    "platform" "qcs615-adp-air/ufs"
    "boot_binaries_download" (dict
        "description" "QCS615 boot binaries"
        "url" "https://softwarecenter.qualcomm.com/download/software/chip/qualcomm_linux-spf-1-0/qualcomm-linux-spf-1-0_test_device_public/r1.0_00096.0/qcs615-le-1-0/common/build/common/bin/QCS615_bootbinaries.zip"
        "name" "qcs615_boot-binaries"
        "filename" "qcs615_boot-binaries.zip"
        "sha256sum" "4500b904d8195e89dd59c0d196e934b88c4737c57b5be20c60f156b8b73e9ddb"
    )
    "cdt_download" (dict
        "description" "QCS615 Ride CDT"
        "url" "https://artifacts.codelinaro.org/artifactory/codelinaro-le/Qualcomm_Linux/QCS615/cdt/ADP_AIR_SA6155P_V2.zip"
        "name" "qcs615-adp-air_cdt"
        "filename" "qcs615-adp-air_cdt.zip"
        "sha256sum" "37d99eb113e286400bce0d70aa12a74d05f93d01f045bf67e7a46b3c606c8fd0"
    )
    "cdt_filename" "cdt_adp_air_sa6155p.bin"
    "dtb" "qcom/qcs615-ride.dtb"
    "disk_image_type" "ufs"
)}}
{{- end }}
{{- if eq $build_qcm6490 "true" }}
{{- $boards = append $boards (dict
    "name" "qcs6490-rb3gen2-vision-kit"
    "silicon_family" "qcm6490"
    "platform" "qcs6490-rb3gen2/ufs"
    "boot_binaries_download" (dict
        "description" "QCM6490 boot binaries"
        "url" "https://softwarecenter.qualcomm.com/download/software/chip/qualcomm_linux-spf-1-0/qualcomm-linux-spf-1-0_test_device_public/r1.0_00095.0/qcm6490-le-1-0/common/build/ufs/bin/QCM6490_bootbinaries.zip"
        "name" "qcm6490_boot-binaries"
        "filename" "qcm6490_boot-binaries.zip"
        "sha256sum" "9c100d7b184ecf0ab9c4be71a8bb7c243fdc79a64380ca3025024dd2b14c5078"
    )
    "cdt_download" (dict
        "description" "RB3 Gen2 Vision Kit CDT"
        "url" "https://artifacts.codelinaro.org/artifactory/codelinaro-le/Qualcomm_Linux/QCS6490/cdt/rb3gen2-vision-kit.zip"
        "name" "qcs6490-rb3gen2-vision-kit_cdt"
        "filename" "qcs6490-rb3gen2-vision-kit_cdt.zip"
        "sha256sum" "a339e297b454c4dc3805fe8cd11d6d8dcb801aa8f0c2dc691561c2785019fa3c"
    )
    "cdt_filename" "cdt_vision_kit.bin"
    "dtb" "qcom/qcs6490-rb3gen2.dtb"
)}}
{{- end }}
{{- if eq $build_qcs8300 "true" }}
{{- $boards = append $boards (dict
    "name" "qcs8300-ride"
    "silicon_family" "qcs8300"
    "platform" "qcs8300-ride-sx/ufs"
    "boot_binaries_download" (dict
        "description" "QCS8300 boot binaries"
        "url" "https://softwarecenter.qualcomm.com/download/software/chip/qualcomm_linux-spf-1-0/qualcomm-linux-spf-1-0_test_device_public/r1.0_00095.0/qcs8300-le-1-0/common/build/ufs/bin/QCS8300_bootbinaries.zip"
        "name" "qcs8300_boot-binaries"
        "filename" "qcs8300_boot-binaries.zip"
        "sha256sum" "463ffd7f20d243a5673ac49d744c8a35a3ab2067c3588be2741c2e6551f5a8f5"
    )
    "cdt_download" (dict
        "description" "QCS8300 Ride SX EVK CDT"
        "url" "https://artifacts.codelinaro.org/artifactory/codelinaro-le/Qualcomm_Linux/QCS8300/cdt/ride-sx.zip"
        "name" "qcs8300-ride-sx_cdt"
        "filename" "qcs8300-ride-sx_cdt.zip"
        "sha256sum" "d7fc667372b28383a36d586333097d84b9d9c104f4dd1845d33904e2d6b39f80"
    )
    "cdt_filename" "cdt_ride_sx.bin"
    "dtb" "qcom/qcs8300-ride.dtb"
)}}
{{- end }}
{{- if eq $build_qcs9100 "true" }}
{{- $boards = append $boards (dict
    "name" "qcs9100-ride-r3"
    "silicon_family" "qcs9100"
    "platform" "qcs9100-ride-sx/ufs"
    "boot_binaries_download" (dict
        "description" "QCS9100 boot binaries"
        "url" "https://softwarecenter.qualcomm.com/download/software/chip/qualcomm_linux-spf-1-0/qualcomm-linux-spf-1-0_test_device_public/r1.0_00095.0/qcs9100-le-1-0/common/build/ufs/bin/QCS9100_bootbinaries.zip"
        "name" "qcs9100_boot-binaries"
        "filename" "qcs9100_boot-binaries.zip"
        "sha256sum" "c201c9e966a706c9e76685ff4298f0940958c4d4877299eee1248ef26b809aa0"
    )
    "cdt_download" (dict
        "description" "QCS9100 Ride Rev3 EVK CDT"
        "url" "https://artifacts.codelinaro.org/artifactory/codelinaro-le/Qualcomm_Linux/QCS9100/cdt/ride-sx_v3.zip"
        "name" "qcs9100-ride-sx-v3_cdt"
        "filename" "qcs9100-ride-sx-v3_cdt.zip"
        "sha256sum" "377a8405899ac82199deaf70bca3648c15b924a3fcef8f109555e661ed70f4b9"
    )
    "cdt_filename" "cdt_ride_sx.bin"
    "dtb" "qcom/qcs9100-ride-r3.dtb"
)}}
{{- end }}
{{- if eq $build_rb1 "true" }}
{{- $boards = append $boards (dict
    "name" "qrb2210-rb1"
    "silicon_family" "qcm2290"
    "platform" "qrb2210-rb1/emmc"
    "boot_binaries_download" (dict
        "description" "RB1 rescue image"
        "url" "https://releases.linaro.org/96boards/rb1/linaro/rescue/23.12/rb1-bootloader-emmc-linux-47528.zip"
        "name" "qrb2210-rb1_rescue-image"
        "filename" "qrb2210-rb1_rescue-image.zip"
        "sha256sum" "c75b6c63eb24c8ca36dad08ba4d4e93f3f4cd7dce60cf1b6dfb5790dc181cc3d"
    )
    "u_boot_file" .u_boot_rb1
)}}
{{- end }}

{{- range $board := $boards }}
  - action: download
    description: Download of {{ $board.boot_binaries_download.description }}
    url: {{ $board.boot_binaries_download.url }}
    name: {{ $board.boot_binaries_download.name }}
    filename: {{ $board.boot_binaries_download.filename }}
  - action: run
    description: Verify SHA256 sum of {{ $board.boot_binaries_download.description }}
    chroot: false
    command:
      echo "{{ $board.boot_binaries_download.sha256sum }} ${ROOTDIR}/../{{ $board.boot_binaries_download.filename }}" |
          sha256sum --strict -c -
  {{- if $board.cdt_download }}
  - action: download
    description: Download of {{ $board.cdt_download.description }}
    url: {{ $board.cdt_download.url }}
    name: {{ $board.cdt_download.name }}
    filename: {{ $board.cdt_download.filename }}
  - action: run
    description: Verify SHA256 sum of {{ $board.cdt_download.description }}
    chroot: false
    command:
      echo "{{ $board.cdt_download.sha256sum }} ${ROOTDIR}/../{{ $board.cdt_download.filename }}" |
          sha256sum --strict -c -
  {{- end }}
{{- end }}

  - action: run
    description: Generate flash directories for eMMC and UFS boards
    chroot: false
    command: |
      set -eux
      # work dir that will be thrown away
      mkdir -v build

      # path to unpacked qcom-ptool tarball
      QCOM_PTOOL="$(ls -d "${ROOTDIR}/../qcom-ptool.tar.gz.d/qcom-ptool-"*)"

      # build a list of supported dtbs from the dtbs tarball
      dtbs_file="build/dtbs.txt"
      : >"${dtbs_file}"
      if [ -f "${ARTIFACTDIR}/dtbs.tar.gz" ]; then
          tar -tzf "${ARTIFACTDIR}/dtbs.tar.gz" --wildcards '*.dtb' \
              >>"$dtbs_file"
      fi

      # optional list of board names to build
      targets_file="build/targets.txt"
      rm -f "${targets_file}"
      case "{{ $target_boards }}" in
        all)
          # no override; build all possible boards (default)
          ;;
        *)
          echo "{{ $target_boards }}" |
              tr ',' '\n' |
              sed '/^$/d' |
              sort -u >"${targets_file}"
          ;;
      esac

{{- range $board := $boards }}
      ### board: {{ $board.name }}
      ### platform: {{ $board.platform }}
      ### silicon family: {{ $board.silicon_family }}

      # set skip_board if target list present and board isn't listed
      skip_board=false
      if [ -e "${targets_file}" ]; then
          if ! grep -Fxq "{{ $board.name }}" "${targets_file}"; then
              skip_board=true
              echo "Skipping board {{ $board.name }}: not in target list"
          fi
      fi
{{- if $board.dtb }}
      # set skip_board if board has a dtb and dtb isn't present
      if ! grep -Fxq "{{ $board.dtb }}" "${dtbs_file}"; then
          skip_board=true
          echo "Skipping board {{ $board.name }}: dtb not available"
      fi
{{- end }}

      # unpack boot binaries
      mkdir -v build/{{ $board.name }}_boot-binaries
      unzip "${ROOTDIR}/../{{ $board.boot_binaries_download.filename }}" \
          -d build/{{ $board.name }}_boot-binaries/unpack
      # strip top directories
      mv build/{{ $board.name }}_boot-binaries/unpack/*/* build/{{ $board.name }}_boot-binaries
      rmdir -v build/{{ $board.name }}_boot-binaries/unpack/* build/{{ $board.name }}_boot-binaries/unpack

      # generate ptool files - various XML files for flashing, GPT data etc.
      mkdir -vp build/ptool/{{ $board.platform }}
      (
          cd build/ptool/{{ $board.platform }}
          conf="${QCOM_PTOOL}/platforms/{{ $board.platform }}/partitions.conf"
          contents="${QCOM_PTOOL}/platforms/{{ $board.platform }}/contents.xml.in"
          disk_type="unknown"
          # make a copy of partitions.conf; infer storage type from lines
          # like:
          #     --disk --type=ufs --size=137438953472 ...
          # or:
          #     --disk --type=emmc --size=76841669632 ...
          # and patch/add filenames for partitions from lines like:
          #     --partition --lun=4 --name=dtb_a ... --filename=dtb.bin
          # or without filename like:
          #     --partition --lun=3 --name=cdt --size=128KB --type-guid=...
          # for data from the following table
          #
          # |--------|--------------|-------------------|-----------------|
          # | data   | ptool name   | ptool filename    | debos filename  |
          # |--------|--------------|-------------------|-----------------|
          # | ESP    | efi          | efi.bin           | disk-media.img1 |
          # | rootfs | rootfs       | rootfs.img        | disk-media.img2 |
          # | DTBs   | dtb_a, dtb_b | dtb.bin           | dtb.bin         |
          # | CDTs   | cdt          | unset / per board | from download   |
          # |--------|--------------|-------------------|-----------------|
          while read line; do
              case "$line" in
                # detect storage type
                "--disk "*)
                  disk_type="$(echo "$line" | sed -n 's/.*--type=\([^ ]*\).*/\1/p')"
                  case $disk_type in
                    "emmc")
                      touch flash-emmc
                      esp="../disk-sdcard.img1"
                      rootfs="../disk-sdcard.img2"
                      ;;
                    "ufs")
                      touch flash-ufs
                      esp="../disk-ufs.img1"
                      rootfs="../disk-ufs.img2"
                      ;;
                  esac
                  ;;
                # read partitions
                "--partition "*)
                  name="$(echo "$line" | sed -n 's/.*--name=\([^ ]*\).*/\1/p')"
                  filename=""
                  case "$name" in
                    dtb_a|dtb_b) filename="dtb.bin";;
                    efi) filename="$esp";;
                    rootfs) filename="$rootfs";;
                    {{- if $board.cdt_download }}
                    cdt) filename={{ $board.cdt_filename }};;
                    {{- end }}
                  esac
                  # override/set filename
                  if [ -n "$filename" ]; then
                      line="$(echo "$line" | sed 's/ --filename=[^ ]*//')"
                      line="${line} --filename=${filename}"
                  fi
                  ;;
              esac
              echo "$line"
          done <"$conf" >partitions.conf
          # generate ptool-partitions.xml from partitions.conf
          "${QCOM_PTOOL}/gen_partition.py" -i partitions.conf \
              -o ptool-partitions.xml
          # generate contents.xml from ptool-partitions.xml and contents.xml.in
          if [ -e "$contents" ]; then
              "${QCOM_PTOOL}/gen_contents.py" -p ptool-partitions.xml \
                  -t "$contents" \
                  -o contents.xml
          fi
          # generate flashing files from qcom-partitions.xml
          "${QCOM_PTOOL}/ptool.py" -x ptool-partitions.xml
      )

      if [ "${skip_board}" = false ]; then
      # create board-specific flash directory
      flash_dir="${ARTIFACTDIR}/flash_{{ $board.name }}"
      rm -rf "${flash_dir}"
      mkdir -v "${flash_dir}"
      # copy platform partition files
      cp --preserve=mode,timestamps -v build/ptool/{{ $board.platform }}/* \
          "${flash_dir}"
      # remove BLANK_GPT and WIPE_PARTITIONS files as it's common for people
      # to run "qdl rawprogram*.xml", mistakingly including these; perhaps
      # ptool should have a flag not to generate these; note that there are
      # wipe_rawprogram*.xml files still
      rm -v "${flash_dir}"/rawprogram*_BLANK_GPT.xml
      rm -v "${flash_dir}"/rawprogram*_WIPE_PARTITIONS.xml
      # copy silicon family boot binaries; these shouldn't ship partition
      # files, but make sure not to accidentally clobber any such file
      find build/{{ $board.name }}_boot-binaries \
          -not -name 'gpt_*' \
          -not -name 'patch*.xml' \
          -not -name 'rawprogram*.xml' \
          -not -name 'wipe*.xml' \
          -not -name 'zeros_*' \
          \( \
              -name LICENSE \
              -or -name Qualcomm-Technologies-Inc.-Proprietary \
              -or -name 'prog_*' \
              -or -name '*.bin' \
              -or -name '*.elf' \
              -or -name '*.fv' \
              -or -name '*.mbn' \
          \) \
          -exec cp --preserve=mode,timestamps -v '{}' "${flash_dir}" \;
      fi
      {{- if $board.u_boot_file }}
      if [ "${skip_board}" = false ]; then
      # copy U-Boot binary to boot.img;
      # qcom-ptool/platforms/*/partitions.conf uses filename=boot.img
      # boot_a and boot_b partitions
      cp --preserve=mode,timestamps -v "${ARTIFACTDIR}/{{ $board.u_boot_file }}" \
          "${flash_dir}/boot.img"
      fi
      {{- end }}

      {{- if $board.cdt_download }}
      if [ "${skip_board}" = false ]; then
      # unpack board CDT
      unzip "${ROOTDIR}/../{{ $board.cdt_download.filename }}" \
          -d build/{{ $board.name }}_cdt
      # copy just the CDT data; no partition or flashing files
      cp --preserve=mode,timestamps -v build/{{ $board.name }}_cdt/{{ $board.cdt_filename }} \
          "${flash_dir}"
      fi
      {{- end }}

      {{- if $board.dtb }}
      if [ "${skip_board}" = false ]; then
      # generate a dtb.bin FAT partition with just a single dtb for the current
      # board; long-term this should really be a set of dtbs and overlays as to
      # share dtb.bin across boards
      dtb_bin="${flash_dir}/dtb.bin"
      rm -f "${dtb_bin}"
      # dtb.bin is only used in UFS based boards at the moment and UFS uses a
      # 4k sector size, so pass -S 4096
      # in qcom-ptool/platforms/*/partitions.conf, dtb_a and _b partitions
      # are provisioned with 64MiB; create a 4MiB FAT that will comfortably fit
      # in these and hold the target device tree, which is 4096 KiB sized
      # blocks for mkfs.vfat's last argument
      mkfs.vfat -S 4096 -C "${dtb_bin}" 4096
      # extract board device tree from the root filesystem provided tarball
      tar -C build -xvf "${ARTIFACTDIR}/dtbs.tar.gz" "{{ $board.dtb }}"
      # copy into the FAT as combined-dtb.dtb
      mcopy -vmp -i "${dtb_bin}" "build/{{ $board.dtb }}" ::/combined-dtb.dtb
      fi
      {{- end }}
{{- end }}

      # cleanup
      rm -rf build

# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause
